## 调试器概貌

在开始各调试动作的具体实现之前，有必要先搭建一个实现框架，后续调试动作的实现过程，我们只需要添加调试命令及对应的处理逻辑即可。

大家在理解了这个框架之后，在阅读到相关调试动作的具体实现章节时，会自然联想到如何定位工程中对应的代码。这对我们后续章节中组织内容、方便读者理解都是比较重要的。

### 功能性需求

调试器的功能性需求，大家联想下常见调试器的使用经历，这个是比较直观的：

-   允许调试可执行程序、调试运行中进程、调试coredump文件；
-   允许对golang代码自动编译构建、调试完成后清理临时构建产物；
-   允许查看源码信息list；
-   允许对二进制文件进行反汇编disass；
-   允许在源码中添加断点breakpoint；
-   允许再源码中添加条件断点；
-   允许next逐语句执行；
-   允许step逐指令执行；
-   允许stepin进入function；
-   允许stepout从function退出；
-   允许print、display显示变量信息、寄存器信息；
-   允许set更新变量、寄存器信息；
-   允许ptype打印变量类型；
-   允许call对函数进行临时调用；
-   允许查看调用堆栈信息bt；
-   允许选择调用栈中的特定栈帧frame；
-   针对golang程序，允许查看goroutines列表、切换goroutine执行；
-   针对golang程序，允许查看threads列表、切换thread执行；
-   等等；

调试器的功能性需求，相对来说是比较直观的，需求会变化，功能也会进行调整。

比如，调试过程中经常不小心错过一个非常关键的事件，想退回几步语句继续调试。通常，我们只能restart调试会话，然后在事件发生位置加断点，然后continue，在代码规模比较大的时候，或者不是很容易复现事件的时候，这种方式也不一定能胜任。

为了进一步提升调试的便利性，就可以为调试器添加record and replay的功能，该功能能够对调试过程进行跟踪记录，并能在需要的时候进行回放，就方便多了。

这个就先不多说了。

### 非功能性需求

做一个产品需要注重用户体验，做一个调试器也一样，需要站在开发者角度考虑如何让开发者用的方便、调试的顺利。

对于一个调试器而言，因为我们会在各种任务间穿插切换，要灵活运行调试命令是必要的。但是一个基于命令行实现的调试器，要想实现命令的输入并不是一件轻松的事情。

-   首先调试器有很多调试命令，如何记忆这些命令是有一定的学习成本的，而基于命令行的调试器学习成本会比基于GUI实现的要学习曲线更陡；
-   基于命令行的调试器，其UI基于终端的文本模式进行显示，而非图形模式，这意味着它不能像GUI界面一样非常灵活方便地展示多种信息，如同时显示源码、断点、变量、寄存器、调用栈信息等；
-   基于命令行的调试器需考虑调试命令输入效率的问题，比如输入命令以及对应的参数。GUI调试器在源码某行处添加一个端点通常是很简单的事情，鼠标点一下即可，但基于命令行的调试器则需要用户显示提供一个源码位置，如"break main.go:15"，或者"break main.main"；
-   调试器诸多调试命令，需要考虑自动补全命令、自动补全参数，如果支持别名，将会是一个不错的选项。调试器还需要记忆上次刚使用过的调试命令，以方便重复使用，例如频繁地逐语句执行动作，next，next，next，其实我们输入next，enter，enter按键序列会更方便一些；
-   好的产品塑造用户习惯，但是更好的习惯应该只有用户自己知道，一个可配置化的调试器是比较合适的，如允许用户自定义命令的别名信息，等等；
-   其他；

### 技术方案