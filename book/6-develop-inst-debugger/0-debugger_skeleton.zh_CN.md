## 调试器概貌

在开始各调试动作的具体实现之前，有必要先搭建一个实现框架，后续调试动作的实现过程，我们只需要添加调试命令及对应的处理逻辑即可。

大家在理解了这个框架之后，在阅读到相关调试动作的具体实现章节时，会自然联想到如何定位工程中对应的代码。这对我们后续章节中组织内容、方便读者理解都是比较重要的。

### 功能性需求

调试器的功能性需求，大家联想下常见调试器的使用经历，这个是比较直观的：

-   允许调试可执行程序、调试运行中进程、调试coredump文件；
-   允许对golang代码自动编译构建、调试完成后清理临时构建产物；
-   允许查看源码信息list；
-   允许对二进制文件进行反汇编disass；
-   允许在源码中添加断点breakpoint；
-   允许再源码中添加条件断点；
-   允许next逐语句执行；
-   允许step逐指令执行；
-   允许stepin进入function；
-   允许stepout从function退出；
-   允许print、display显示变量信息、寄存器信息；
-   允许set更新变量、寄存器信息；
-   允许ptype打印变量类型；
-   允许call对函数进行临时调用；
-   允许查看调用堆栈信息bt；
-   允许选择调用栈中的特定栈帧frame；
-   针对golang程序，允许查看goroutines列表、切换goroutine执行；
-   针对golang程序，允许查看threads列表、切换thread执行；
-   等等；

调试器的功能性需求，相对来说是比较直观的，需求会变化，功能也会进行调整。

比如，调试过程中经常不小心错过一个非常关键的事件，想退回几步语句继续调试。通常，我们只能restart调试会话，然后在事件发生位置加断点，然后continue，在代码规模比较大的时候，或者不是很容易复现事件的时候，这种方式也不一定能胜任。

为了进一步提升调试的便利性，就可以为调试器添加record and replay的功能，该功能能够对调试过程进行跟踪记录，并能在需要的时候进行回放，就方便多了。

这个就先不多说了。

### 非功能性需求



### 技术方案